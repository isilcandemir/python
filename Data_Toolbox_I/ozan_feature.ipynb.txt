{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.linear_model import LinearRegression\n",
    "import pandas as pd\n",
    "from scipy.stats import kendalltau"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fill this function to construct a data frame X that contains your final features extracted from the dataset\n",
    "def construct_features(df):\n",
    "    df_new = df[['Season','Club','Market Value']]\n",
    "    df_highMVal = pd.DataFrame(df_new.groupby(['Season']).quantile([0.80])['Market Value'])\n",
    "    df_highMVal = df_highMVal.reset_index()\n",
    "    df_highMVal.columns = ['Season', 'Quantile', 'High Market Value']\n",
    "    df_highMVal.drop(labels='Quantile',inplace=True,axis=1)\n",
    "    df=df.merge(df_highMVal,on='Season',how='left')\n",
    "    df['Valuable'] = df['Market Value'] > df['High Market Value']\n",
    "    df_numHighMVal = df.groupby(['Season','Club']).sum()['Valuable'].reset_index()\n",
    "    X = df_numHighMVal['Valuable']\n",
    "    return X\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Fill this function to construct a data frame y that contains the labels of the test data\n",
    "def construct_labels(df):\n",
    "    pass\n",
    "    return y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# If you try to choose to predict points instead of rankings then you should implement this function as well\n",
    "# to generate rankings. If you predict the rankings directly, you can leave this function as it is.\n",
    "def convert_points_to_predictions(predictions):\n",
    "    pass\n",
    "    return predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-5-5f0853e6a864>, line 18)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-5-5f0853e6a864>\"\u001b[0;36m, line \u001b[0;32m18\u001b[0m\n\u001b[0;31m    f.print(tau)\u001b[0m\n\u001b[0m          ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "# This function will evaluate your features test performance using the ranking predictions\n",
    "def compute_test_score(outfile_name):\n",
    "    # X_test should contain the feature you engineered and y_test should contain the corresponding labels, which are team rankings \n",
    "    X_test = construct_features(pd.read_excel('test_data.xlsx',sheet_name='Player'))\n",
    "    y_test = construct_labels(pd.read_excel('test_data.xlsx',sheet_name='Points'))\n",
    "    # This is the regression model you will use\n",
    "    final_model = LinearRegression(fit_intercept=False)\n",
    "    final_model.fit(X_train,y_train)\n",
    "    # Your model's predictions will be stored in this array\n",
    "    predictions = final_model.predict(X_test)\n",
    "    # Your model can predict either points or rankings. If necessary, change the function above\n",
    "    predictions = convert_points_to_rankings(predictions)\n",
    "    # Your performance on the test set\n",
    "    tau, _ = kendalltau(predictions, y_test)\n",
    "    # Print tau both to file and screen\n",
    "    print(tau)\n",
    "    f = open(outfile_name, 'w')\n",
    "    f.print(tau)\n",
    "    f.close()\n",
    "\n",
    "#outfile name should have the format ID1_ID2_ID3.txt\n",
    "outfile_name = None\n",
    "compute_test_score(outfile_name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
